<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="ttystyle.css" />
    </head>
    <body class="ttydoc"><pre class="ttydoc">
All <a href="int.html#int20h_winvxd" class="ttydoc">INT 20h</a> Windows inter-VxD functions, ordered by device and service call numbers.

These calls are only valid from Ring 0 of the Windows kernel, when running in
386 enhanced mode (32-bit protected mode). In any other case, INT 20h is
handled as the traditional DOS termination call.

This form of calling is how VxDs communicate between each other and the Windows
kernel in Windows 3.0, 3.1, 95, 98, and ME. This documentation does not apply
to Windows NT.

INT 20h is handled with the expectation that 4 bytes follow the instruction.
On return from INT 20h the instruction pointer is set 4 bytes past the first
byte past INT 20h.

Definitions:
        VxD device number: a 16-bit word associated with a VxD.
                           this number is assigned by Microsoft.

        VxD service index: a 15-bit index into the VxD's service table.
                           some VxDs do not have a service table.

                           only bits 14:0 define the index.

                           the MSB (bit 15) is set if the instruction
                           is a JMP rather than a CALL.

As assembler directives:
        CD 20           INT 20H
        ss ss           DW service index + JMP flag
        dd dd           DW device number

Alternative definition:
        CD 20           INT 20H
        ss ss dd dd     DD (device number &lt;&lt; 16) + service index

Microsoft DDK macro:
        CD 20 ss ss dd dd   VxDcall (device number &lt;&lt; 16) + service index
        CD 20 ss ss dd dd   VxDjmp (device number &lt;&lt; 16) + service index + 0x8000

Undefined_Device_ID is a special device ID for VxDs that do not need to provide
services in Windows 3.x, and for VxDs that are dynamically loadable at runtime
in Windows 95 and later.

Most VxD services pass parameters using the CPU registers. Some calls also take
parameters through the stack using a __cdecl calling convention, where
parameters are pushed onto the stack right-to-left and the caller is expected
to remove the parameters from the stack after the call.

It's interesting to note the VxDcall and VxDjmp macros provided by Microsoft in
their DDK allow parameters to be specified after VxDcall/VxDjmp following the
VxD device and service call number, where the macro will then generate PUSH
instructions for each parameter and generate "ADD ESP,&lt;n&gt;" after the
VxDcall automatically.

Example:
        VxDcall     SomeVXDServiceCallThatNeedsParams, 0x12345678, EBX

Becomes:
        push        EBX
        push        0x12345678
        INT         20h
        DD          SomeVXDServiceCallThatNeedsParams
        add         esp,8                       ; two 32-bit PUSHes = 8 bytes

For obvious reasons, parameters are NOT allowed for VxDjmp calls.

For performance reasons, upon execution of a VxDcall/VxDjmp instruction,
Windows will patch the INT 20h sequence with a CALL FAR ptr or JMP FAR ptr
instruction. The slow process of searching the VxD linked list for a device
ID, then looking up the service index, is done only once for every site in the
driver's code when first encountered by the CPU after the driver is loaded
into memory.

The purpose of allowing a JMP to a VxD service, rather than a call, is
(apparently) to allow the last service call in a driver's subroutine to
return to Windows directly rather than return to the subroutine and then RET.

Consider for example:

            ; some code....
            VxDcall     SomeCall
            ; some code....
            VxDcall     SomeOtherCall
            ret

Some sample code in their DDK will instead do this:

            ; some code....
            VxDcall     SomeCall
            ; some code....
            VxDjmp      SomeOtherCall

The obvious reason this is done is to avoid using additional stack and to let
the VxDcall do the work of returning to the caller instead of wasting time
returning to a subroutine that will immediately RET anyway. Another way to put
it, is to say that VxDjmp enables Windows drivers to execute a "tail call".

The minimum Windows version required is included for reference.

═══════════════════════════════════════════════════════════════════════════════
Version │ Dev / Srv │ Description
────────┴───────────┴──────────────────────────────────────────────────────────
         0000H        Undefined_Device_ID
3.0+     0001H        VMM_Device_ID
3.0+     0001H 0000H  Get_VMM_Version
3.0+     0001H 0001H  Get_Cur_VM_Handle
3.0+     0001H 0002H  Test_Cur_VM_Handle
3.0+     0001H 0003H  Get_Sys_VM_Handle
3.0+     0001H 0004H  Test_Sys_VM_Handle
3.0+     0001H 0005H  Validate_VM_Handle
3.0+     0002H        Debug_Device_ID
3.0+     0003H        VPICD_Device_ID
3.0+     0004H        VDMAD_Device_ID
3.0+     0005H        VTD_Device_ID
3.0+     0006H        V86MMGR_Device_ID
3.0+     0007H        PageSwap_Device_ID
3.0+     0008H        Parity_Device_ID
3.0+     0009H        Reboot_Device_ID
3.0+     000AH        VDD_Device_ID
3.0+     000BH        VSD_Device_ID
3.0+     000CH        VMD_Device_ID
3.0+     000DH        VKD_Device_ID
3.0+     000EH        VCD_Device_ID
3.0+     000FH        VPD_Device_ID

───────────────────────────────────────────────────────────────────────────
References:

  Ralph Brown Interrupt List
    [http://www.ctyme.com/intr/int-21.htm]
</pre></body>
</html>

