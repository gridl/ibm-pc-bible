<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="ttystyle.css" />
    </head>
    <body class="ttydoc"><pre class="ttydoc">
All <a href="int.html#int20h_winvxd" class="ttydoc">INT 20h</a> Windows inter-VxD functions, ordered by device and service call numbers.

These calls are only valid from Ring 0 of the Windows kernel, when running in
386 enhanced mode (32-bit protected mode). In any other case, INT 20h is
handled as the traditional DOS termination call.

This form of calling is how VxDs communicate between each other and the Windows
kernel in Windows 3.0, 3.1, 95, 98, and ME. This documentation does not apply
to Windows NT.

INT 20h is handled with the expectation that 4 bytes follow the instruction.
On return from INT 20h the instruction pointer is set 4 bytes past the first
byte past INT 20h.

Definitions:
        VxD device number: a 16-bit word associated with a VxD.
                           this number is assigned by Microsoft.

        VxD service index: a 15-bit index into the VxD's service table.
                           some VxDs do not have a service table.

                           only bits 14:0 define the index.

                           the MSB (bit 15) is set if the instruction
                           is a JMP rather than a CALL.

As assembler directives:
        CD 20           INT 20H
        ss ss           DW service index + JMP flag
        dd dd           DW device number

Alternative definition:
        CD 20           INT 20H
        ss ss dd dd     DD (device number &lt;&lt; 16) + service index

Microsoft DDK macro:
        CD 20 ss ss dd dd   VxDcall (device number &lt;&lt; 16) + service index
        CD 20 ss ss dd dd   VxDjmp (device number &lt;&lt; 16) + service index + 0x8000

Undefined_Device_ID is a special device ID for VxDs that do not need to provide
services in Windows 3.x, and for VxDs that are dynamically loadable at runtime
in Windows 95 and later.

Most VxD services pass parameters using the CPU registers. Some calls also take
parameters through the stack using a __cdecl calling convention, where
parameters are pushed onto the stack right-to-left and the caller is expected
to remove the parameters from the stack after the call.

It's interesting to note the VxDcall and VxDjmp macros provided by Microsoft in
their DDK allow parameters to be specified after VxDcall/VxDjmp following the
VxD device and service call number, where the macro will then generate PUSH
instructions for each parameter and generate "ADD ESP,&lt;n&gt;" after the
VxDcall automatically.

Example:
        VxDcall     SomeVXDServiceCallThatNeedsParams, 0x12345678, EBX

Becomes:
        push        EBX
        push        0x12345678
        INT         20h
        DD          SomeVXDServiceCallThatNeedsParams
        add         esp,8                       ; two 32-bit PUSHes = 8 bytes

For obvious reasons, parameters are NOT allowed for VxDjmp calls.

For performance reasons, upon execution of a VxDcall/VxDjmp instruction,
Windows will patch the INT 20h sequence with a CALL FAR ptr or JMP FAR ptr
instruction. The slow process of searching the VxD linked list for a device
ID, then looking up the service index, is done only once for every site in the
driver's code when first encountered by the CPU after the driver is loaded
into memory.

The purpose of allowing a JMP to a VxD service, rather than a call, is
to allow the last service call in a driver's subroutine to return to caller
indirectly through the VxD service call.

Consider for example:

            ; some code....
            VxDcall     SomeCall
            ; some code....
            VxDcall     SomeOtherCall
            ret

Some sample code in their DDK will instead do this:

            ; some code....
            VxDcall     SomeCall
            ; some code....
            VxDjmp      SomeOtherCall

The obvious reason this is done is to avoid using additional stack and to let
the VxDcall do the work of returning to the caller instead of wasting time
returning to a subroutine that will immediately RET anyway. Another way to put
it, is to say that VxDjmp enables Windows drivers to execute a "tail call".

The minimum Windows version required is included for reference.

═══════════════════════════════════════════════════════════════════════════════
Version │ Dev / Srv │ Description
────────┴───────────┴──────────────────────────────────────────────────────────
         0000H        Undefined_Device_ID
3.0+     0001H        VMM_Device_ID
3.0+     0001H 0000H  Get_VMM_Version
3.0+     0001H 0001H  Get_Cur_VM_Handle
3.0+     0001H 0002H  Test_Cur_VM_Handle
3.0+     0001H 0003H  Get_Sys_VM_Handle
3.0+     0001H 0004H  Test_Sys_VM_Handle
3.0+     0001H 0005H  Validate_VM_Handle
3.0+     0001H 0006H  Get_VMM_Reenter_Count
3.0+     0001H 0007H  Begin_Reentrant_Execution
3.0+     0001H 0008H  End_Reentrant_Execution
3.0+     0001H 0009H  Install_V86_Break_Point
3.0+     0001H 000AH  Remove_V86_Break_Point
3.0+     0001H 000BH  Allocate_V86_Call_Back
3.0+     0001H 000CH  Allocate_PM_Call_Back
3.0+     0001H 000DH  Call_When_VM_Returns
3.0+     0001H 000EH  Schedule_Global_Event
3.0+     0001H 000FH  Schedule_VM_Event
3.0+     0001H 0010H  Call_Global_Event
3.0+     0001H 0011H  Call_VM_Event
3.0+     0001H 0012H  Cancel_Global_Event
3.0+     0001H 0013H  Cancel_VM_Event
3.0+     0001H 0014H  Call_Priority_VM_Event
3.0+     0001H 0015H  Cancel_Priority_VM_Event
3.0+     0001H 0016H  Get_NMI_Handler_Addr
3.0+     0001H 0017H  Set_NMI_Handler_Addr
3.0+     0001H 0018H  Hook_NMI_Event
3.0+     0001H 0019H  Call_When_VM_Ints_Enabled
3.0+     0001H 001AH  Enable_VM_Ints
3.0+     0001H 001BH  Disable_VM_Ints
3.0+     0001H 001CH  Map_Flat
3.0+     0001H 001DH  Map_Lin_To_VM_Addr
3.0+     0001H 001EH  Adjust_Exec_Priority
3.0+     0001H 001FH  Begin_Critical_Section
3.0+     0001H 0020H  End_Critical_Section
3.0+     0001H 0021H  End_Crit_And_Suspend
3.0+     0001H 0022H  Claim_Critical_Section
3.0+     0001H 0023H  Release_Critical_Section
3.0+     0001H 0024H  Call_When_Not_Critical
3.0+     0001H 0025H  Create_Semaphore
3.0+     0001H 0026H  Destroy_Semaphore
3.0+     0001H 0027H  Wait_Semaphore
3.0+     0001H 0028H  Signal_Semaphore
3.0+     0001H 0029H  Get_Crit_Section_Status
3.0+     0001H 002AH  Call_When_Task_Switched
3.0+     0001H 002BH  Suspend_VM
3.0+     0001H 002CH  Resume_VM
3.0+     0001H 002DH  No_Fail_Resume_VM
3.0+     0001H 002EH  Nuke_VM
3.0+     0001H 002FH  Crash_Cur_VM
3.0+     0001H 0030H  Get_Execution_Focus
3.0+     0001H 0031H  Set_Execution_Focus
3.0+     0001H 0032H  Get_Time_Slice_Priority
3.0+     0001H 0033H  Set_Time_Slice_Priority
3.0+     0001H 0034H  Get_Time_Slice_Granularity
3.0+     0001H 0035H  Set_Time_Slice_Granularity
3.0+     0001H 0036H  Get_Time_Slice_Info
3.0+     0001H 0037H  Adjust_Execution_Time
3.0+     0001H 0038H  Release_Time_Slice
3.0+     0001H 0039H  Wake_Up_VM
3.0+     0001H 003AH  Call_When_Idle
3.0+     0001H 003BH  Get_Next_VM_Handle
3.0+     0001H 003CH  Set_Global_Time_Out
3.0+     0001H 003DH  Set_VM_Time_Out
3.0+     0001H 003EH  Cancel_Time_Out
3.0+     0001H 003FH  Get_System_Time
3.0+     0001H 0040H  Get_VM_Exec_Time
3.0+     0001H 0041H  Hook_V86_Int_Chain
3.0+     0001H 0042H  Get_V86_Int_Vector
3.0+     0001H 0043H  Set_V86_Int_Vector
3.0+     0001H 0044H  Get_PM_Int_Vector
3.0+     0001H 0045H  Set_PM_Int_Vector
3.0+     0001H 0046H  Simulate_Int
3.0+     0001H 0047H  Simulate_Iret
3.0+     0001H 0048H  Simulate_Far_Call
3.0+     0001H 0049H  Simulate_Far_Jmp
3.0+     0001H 004AH  Simulate_Far_Ret
3.0+     0001H 004BH  Simulate_Far_Ret_N
3.0+     0001H 004CH  Build_Int_Stack_Frame
3.0+     0001H 004DH  Simulate_Push
3.0+     0001H 004EH  Simulate_Pop
3.0+     0001H 004FH  _HeapAllocate
3.0+     0001H 0050H  _HeapReAllocate
3.0+     0001H 0051H  _HeapFree
3.0+     0001H 0052H  _HeapGetSize
3.0+     0001H 0053H  _PageAllocate
3.0+     0001H 0054H  _PageReAllocate
3.0+     0001H 0055H  _PageFree
3.0+     0001H 0056H  _PageLock
3.0+     0001H 0057H  _PageUnLock
3.0+     0001H 0058H  _PageGetSizeAddr
3.0+     0001H 0059H  _PageGetAllocInfo
3.0+     0001H 005AH  _GetFreePageCount
3.0+     0001H 005BH  _GetSysPageCount
3.0+     0001H 005CH  _GetVMPgCount
3.0+     0001H 005DH  _MapIntoV86
3.0+     0001H 005EH  _PhysIntoV86
3.0+     0001H 005FH  _TestGlobalV86Mem
3.0+     0001H 0060H  _ModifyPageBits
3.0+     0001H 0061H  _CopyPageTable
3.0+     0001H 0062H  _LinMapIntoV86
3.0+     0001H 0063H  _LinPageLock
3.0+     0001H 0064H  _LinPageUnLock
3.0+     0001H 0065H  _SetResetV86Pageable
3.0+     0001H 0066H  _GetV86PageableArray
3.0+     0001H 0067H  _PageCheckLinRange
3.0+     0001H 0068H  _PageOutDirtyPages
3.0+     0001H 0069H  _PageDiscardPages
3.0+     0001H 006AH  _GetNulPageHandle
3.0+     0001H 006BH  _GetFirstV86Page
3.0+     0001H 006CH  _MapPhysToLinear
3.0+     0001H 006DH  _GetAppFlatDSAlias
3.0+     0001H 006EH  _SelectorMapFlat
3.0+     0001H 006FH  _GetDemandPageInfo
3.0+     0001H 0070H  _GetSetPageOutCount
3.0+     0001H 0071H  Hook_V86_Page
3.0+     0001H 0072H  _Assign_Device_V86_Pages
3.0+     0001H 0073H  _DeAssign_Device_V86_Pages
3.0+     0001H 0074H  _Get_Device_V86_Pages_Array
3.0+     0001H 0075H  MMGR_SetNULPageAddr
3.0+     0001H 0076H  _Allocate_GDT_Selector
3.0+     0001H 0077H  _Free_GDT_Selector
3.0+     0001H 0078H  _Allocate_LDT_Selector
3.0+     0001H 0079H  _Free_LDT_Selector
3.0+     0001H 007AH  _BuildDescriptorDWORDs
3.0+     0001H 007BH  _GetDescriptor
3.0+     0001H 007CH  _SetDescriptor
3.0+     0001H 007DH  _MMGR_Toggle_HMA
3.0+     0001H 007EH  Get_Fault_Hook_Addrs
3.0+     0001H 007FH  Hook_V86_Fault
3.0+     0001H 0080H  Hook_PM_Fault
3.0+     0001H 0081H  Hook_VMM_Fault
3.0+     0001H 0082H  Begin_Nest_V86_Exec
3.0+     0001H 0083H  Begin_Nest_Exec
3.0+     0001H 0084H  Exec_Int
3.0+     0001H 0085H  Resume_Exec
3.0+     0001H 0086H  End_Nest_Exec
3.0+     0001H 0087H  Allocate_PM_App_CB_Area
3.0+     0001H 0088H  Get_Cur_PM_App_CB
3.0+     0001H 0089H  Set_V86_Exec_Mode
3.0+     0001H 008AH  Set_PM_Exec_Mode
3.0+     0001H 008BH  Begin_Use_Locked_PM_Stack
3.0+     0001H 008CH  End_Use_Locked_PM_Stack
3.0+     0001H 008DH  Save_Client_State
3.0+     0001H 008EH  Restore_Client_State
3.0+     0001H 008FH  Exec_VxD_Int
3.0+     0001H 0090H  Hook_Device_Service
3.0+     0001H 0091H  Hook_Device_V86_API
3.0+     0001H 0092H  Hook_Device_PM_API
3.0+     0001H 0093H  System_Control
3.0+     0001H 0094H  Simulate_IO
3.0+     0001H 0095H  Install_Mult_IO_Handlers
3.0+     0001H 0096H  Install_IO_Handler
3.0+     0001H 0097H  Enable_Global_Trapping
3.0+     0001H 0098H  Enable_Local_Trapping
3.0+     0001H 0099H  Disable_Global_Trapping
3.0+     0001H 009AH  Disable_Local_Trapping
3.0+     0001H 009BH  List_Create
3.0+     0001H 009CH  List_Destroy
3.0+     0001H 009DH  List_Allocate
3.0+     0001H 009EH  List_Attach
3.0+     0001H 009FH  List_Attach_Tail
3.0+     0001H 00A0H  List_Insert
3.0+     0001H 00A1H  List_Remove
3.0+     0001H 00A2H  List_Deallocate
3.0+     0001H 00A3H  List_Get_First
3.0+     0001H 00A4H  List_Get_Next
3.0+     0001H 00A5H  List_Remove_First
3.0+     0001H 00A6H  _AddInstanceItem
3.0+     0001H 00A7H  _Allocate_Device_CB_Area
3.0+     0001H 00A8H  _Allocate_Global_V86_Data_Area
3.0+     0001H 00A9H  _Allocate_Temp_V86_Data_Area
3.0+     0001H 00AAH  _Free_Temp_V86_Data_Area
3.0+     0001H 00ABH  Get_Profile_Decimal_Int
3.0+     0001H 00ACH  Convert_Decimal_String
3.0+     0001H 00ADH  Get_Profile_Fixed_Point
3.0+     0001H 00AEH  Convert_Fixed_Point_String
3.0+     0001H 00AFH  Get_Profile_Hex_Int
3.0+     0001H 00B0H  Convert_Hex_String
3.0+     0001H 00B1H  Get_Profile_Boolean
3.0+     0001H 00B2H  Convert_Boolean_String
3.0+     0001H 00B3H  Get_Profile_String
3.0+     0001H 00B4H  Get_Next_Profile_String
3.0+     0001H 00B5H  Get_Environment_String
3.0+     0001H 00B6H  Get_Exec_Path
3.0+     0001H 00B7H  Get_Config_Directory
3.0+     0001H 00B8H  OpenFile
3.0+     0001H 00B9H  Get_PSP_Segment
3.0+     0001H 00BAH  GetDOSVectors
3.0+     0001H 00BBH  Get_Machine_Info
3.0+     0001H 00BCH  GetSet_HMA_Info
3.0+     0001H 00BDH  Set_System_Exit_Code
3.0+     0001H 00BEH  Fatal_Error_Handler
3.0+     0001H 00BFH  Fatal_Memory_Error
3.0+     0001H 00C0H  Update_System_Clock
3.0+     0001H 00C1H  Test_Debug_Installed
3.0+     0001H 00C2H  Out_Debug_String
3.0+     0001H 00C3H  Out_Debug_Chr
3.0+     0001H 00C4H  In_Debug_Chr
3.0+     0001H 00C5H  Debug_Convert_Hex_Binary
3.0+     0001H 00C6H  Debug_Convert_Hex_Decimal
3.0+     0001H 00C7H  Debug_Test_Valid_Handle
3.0+     0001H 00C8H  Validate_Client_Ptr
3.0+     0001H 00C9H  Test_Reenter
3.0+     0001H 00CAH  Queue_Debug_String
3.0+     0001H 00CBH  Log_Proc_Call
3.0+     0001H 00CCH  Debug_Test_Cur_VM
3.0+     0001H 00CDH  Get_PM_Int_Type
3.0+     0001H 00CEH  Set_PM_Int_Type
3.0+     0001H 00CFH  Get_Last_Updated_System_Time
3.0+     0001H 00D0H  Get_Last_Updated_VM_Exec_Time
3.1+     0001H 00D1H  Test_DBCS_Lead_Byte
3.1+     0001H 00D2H  _AddFreePhysPage
3.1+     0001H 00D3H  _PageResetHandlePAddr
3.1+     0001H 00D4H  _SetLastV86Page
3.1+     0001H 00D5H  _GetLastV86Page
3.1+     0001H 00D6H  _MapFreePhysReg
3.1+     0001H 00D7H  _UnmapFreePhysReg
3.1+     0001H 00D8H  _XchgFreePhysReg
3.1+     0001H 00D9H  _SetFreePhysRegCalBk
3.1+     0001H 00DAH  Get_Next_Arena
3.1+     0001H 00DBH  Get_Name_Of_Ugly_TSR
3.1+     0001H 00DCH  Get_Debug_Options
3.1+     0001H 00DDH  Set_Physical_HMA_Alias
3.1+     0001H 00DEH  _GetGlblRng0V86IntBase
3.1+     0001H 00DFH  _Add_Global_V86_Data_Area
3.1+     0001H 00E0H  GetSetDetailedVMError
3.1+     0001H 00E1H  Is_Debug_Chr
3.1+     0001H 00E2H  Clear_Mono_Screen
3.1+     0001H 00E3H  Out_Mono_Chr
3.1+     0001H 00E4H  Out_Mono_String
3.1+     0001H 00E5H  Set_Mono_Cur_Pos
3.1+     0001H 00E6H  Get_Mono_Cur_Pos
3.1+     0001H 00E7H  Get_Mono_Chr
3.1+     0001H 00E8H  Locate_Byte_In_ROM
3.1+     0001H 00E9H  Hook_Invalid_Page_Fault
3.1+     0001H 00EAH  Unhook_Invalid_Page_Fault
3.1+     0001H 00EBH  Set_Delete_On_Exit_File
3.1+     0001H 00ECH  Close_VM
3.1+     0001H 00EDH  Enable_Touch_1st_Meg
3.1+     0001H 00EEH  Disable_Touch_1st_Meg
3.1+     0001H 00EFH  Install_Exception_Handler
3.1+     0001H 00F0H  Remove_Exception_Handler
3.1+     0001H 00F1H  Get_Crit_Status_No_Block
3.0+     0002H        Debug_Device_ID
3.0+     0003H        VPICD_Device_ID
3.0+     0004H        VDMAD_Device_ID
3.0+     0005H        VTD_Device_ID
3.0+     0006H        V86MMGR_Device_ID
3.0+     0007H        PageSwap_Device_ID
3.0+     0008H        Parity_Device_ID
3.0+     0009H        Reboot_Device_ID
3.0+     000AH        VDD_Device_ID
3.0+     000BH        VSD_Device_ID
3.0+     000CH        VMD_Device_ID
3.0+     000DH        VKD_Device_ID
3.0+     000EH        VCD_Device_ID
3.0+     000FH        VPD_Device_ID

───────────────────────────────────────────────────────────────────────────
References:

  Ralph Brown Interrupt List
    [http://www.ctyme.com/intr/int-21.htm]
</pre></body>
</html>

